---
title: Q.SOLID 원칙
#author: Yoojeong
date: 2024-11-07 13:30:00 +0800
categories: [Study, C/C++]
tags: [c, c++, tech interview]
render_with_liquid: false
---

SOLID 원칙은 객체 지향 프로그래밍과 설계에서  
유지 보수성과 확장성을 높이기 위해 사용되는 다섯 가지 원칙입니다.  

<br>

---

<br>

1. <span style="background-color:#fff9c4; padding:0.1em 0.3em; border-radius:4px;">**SRP 단일 책임의 원칙**</span> : 각 클래스는 **하나의 책임**만 가져야 합니다. 즉, 클래스는 오직 하나의 기능이나 역할만 담당하도록 설계되어야 합니다.  

2. <span style="background-color:#fff9c4; padding:0.1em 0.3em; border-radius:4px;">**OCP 개방-폐쇠 원칙**</span> : 새로운 기능을 추가할 때 **기존 코드를 변경하지 않고 확장**할 수 있도록 설계되어야 합니다.  
<span style="color:gray">(도형 넓이 계산 함수 상속받아서 자식에서 구현, 무기 예시 weapon아래에 총검활이 있다.)</span>  

3. <span style="background-color:#fff9c4; padding:0.1em 0.3em; border-radius:4px;">**LSP 리스코프 치환 원칙**</span> : **하의 클래스는 기본 클래스를 대체** 할 수 있어야합니다. 기본클래스의 방향성을 유지해야 합니다.  
<span style="color:gray"> car, train예시 (자식 클래스에서 부모 클래스에서 상속받은 함수를 무효화하지 말기)  
몬스터라는 상위 클래스가 있고, 어택이라는 함수가 있습니다. 몬스터 클래스를 상속받는 고블린, 드래곤 등이 있습니다. 그런데 드래곤은 어택에 추가적인 매개변수가 더 필요한 상황이 되어서 부모 클래스를 수정해야 하는 상황이 되면 안됩니다. </span>  

4. <span style="background-color:#fff9c4; padding:0.1em 0.3em; border-radius:4px;">**ISP 인터페이스 분리 원칙**</span> : 인터페이스를 작게 유지해서, 클라이언트는 필요한것만 구현 합니다.  
<span style="color:gray">(대미지를 받는, 폭발하는, 무버블, 회전가능한 등의 인터페이스로 잘게 분리합니다., 새 클래스 펭귄 날다)</span>  

5. <span style="background-color:#fff9c4; padding:0.1em 0.3em; border-radius:4px;">**DIP 의존 역전 원칙**</span> : **고수준 모듈은 저수준 모듈에 의존해서는 안되며, 둘 다 추상화에 의존**해야 합니다.  
이는 코드의 결합도를 낮추기 위해 구체적인 구현보다 추상화된 인터페이스에 의존하도록 설계해야 한다는 의미입니다.  
어떤 클래스를 참조해서 사용해야하는 상황이 생긴다면, 그 클래스를 직접 참조하는 것이 아니라 그 대상의 상위 요소(추상 클래스or인터페이스)로 참조하라는 원칙.  
즉, **구현 클래스에 의존하지 말고, 인터페이스에 의존**하라는 뜻.  
<span style="color:gray">(스위치와 문. 스위치가 문을 의존하지 않도록 스위처블 인터페이스를 만들어서 스위치는 말 그대로 활성 비활성만 수행 하도록 구현합니다.)</span>  

<br>

---

<br>

Q. 왜 솔리드 원칙을 쓰는가?
- **유지보수**가 핵심이다. 약한 결합도와 높은 응집도 때문에 사용한다.