---
title: Q.가상함수와 추상클래스
#author: Yoojeong
date: 2024-11-07 14:00:00 +0800
categories: [Study, C/C++]
tags: [c, c++, tech interview]
render_with_liquid: false
---

## 가상함수
가상함수는 `virtual` 키워드가 붙은 함수이며, 자식 클래스에서 정의할 멤버 함수 입니다.  
부모 클래스의 포인터나 레퍼런스가 자식 클래스 객체를 가리킬 때,  
자식 클래스에서 의 가상함수 **재정의에 의해 호출되는 함수가 달라지게 합니다.**


<br>

객체의 가상 함수 포인터를 통해 클래스의 가상 함수 테이블에 접근합니다.  
vtable 안의 함수 포인터를 호출하는식으로 동작.  

<br>

---


### Q. 추상클래스는 무엇이고 왜 사용하는가?  
<details class="custom-collapse">
  <summary>답변 보기</summary>
  추상클래스는 하나 이상의 순수 가상 함수를 포함하는 클래스입니다. 구체적인 구현을 제공하지 않고, 자식 클래스에서 구현을 강제합니다. <br>
  추상 클래스를 사용하는 이유는 여러 클래스 간의 공통된 함수나 속성을 정의해 중복코드를 줄이고, 일관성을 유지하기 위함입니다. 또한, 자식 클래스에서 오버라이드 해주지 않으면 오류가 나오기 때문에 실수를 방지할 수 있습니다.  
</details>


### Q. 생성자/소멸자에서 virtual 함수 호출시?  
<details class="custom-collapse">
  <summary>답변 보기</summary>
  - 해당 시점에 **파생 클래스 부분은 초기화되지 않음**. <br> 
  - 따라서 **기본 클래스의 버전만 호출**됨 → 다형성이 깨짐. <br>
  - 생성자/소멸자 내에서는 `virtual` 호출을 지양.  <br>
</details>
 

### Q. 추상클래스와 인터페이스의 차이점?   
<details class="custom-collapse">
  <summary>답변 보기</summary>
  추상클래스는 일부 함수를 구현할 수 있고 멤버변수도 가질 수 있는 반면, 인터페이스는 순수 가상 함수만을 가진 클래스로 구현됩니다. 즉, 인터페이스는 구현을 전혀 제공하지 않는 클래스입니다.   <br>

   <br>

  인터페이스는 구현이 없기 때문에 여러 인터페이스를 동시에 상속받을 때 충돌을 피할 수 있습니다. (인터페이스는 다중 상속 가능)  <br>

   <br>

  인터페이스를 사용하는 이유는 코드의 유연성, 모듈화, 다중 상속 가능성, 명확한 계약 정의와 같은 장점을 극대화하기 위함입니다. 반면에 추상 클래스는 기본적인 구현을 제공하고, 상태를 관리할 수 있기 때문에 주로 상속받는 클래스에 공통된 기능을 제공하는데 유리합니다.    
</details>


### Q. 추상 클래스도 인터페이스라고 말할 수 있는데 왜 인터페이스가 아니라 추상클래스인가?
<details class="custom-collapse">
  <summary>답변 보기</summary>
  서로 의도가 다릅니다. 추상 클래스는 공통된 정체성을 가진 계열의 기본 뼈대이고, 인터페이스는 서로 다른 클래스들이 공유할 수 있는 기능적 계약입니다.  <br>  
  예를들어 character, weapon, effect는 추상클래스, IRenderable, IDamageable, IUpdatable은 인터페이스로 표현합니다. <br>

   <br>

  추상 클래스의 목적은 이 계열의 객체들은 기본적으로 같은 성질과 동작을 공유한다,  <br> 
  인터페이스의 목적은 이 기능을 할 수 있다라는 능력의 선언(구현<역할)
</details>
 

### Q. 왜 추상클래스는 인스턴스화 할 수 없는가?  
<details class="custom-collapse">
  <summary>답변 보기</summary>
  완전하지 않은 클래스이기 때문입니다. 추상 클래스는 하나 이상의 순수 가상 함수를 포함하며, 이 함수는 구현이 없고 자식 클래스에서 구현해야 합니다. 즉 구체적인 구현은 자식 클래스가 제공해야 합니다. <br>

  <br>

  1. 불완전한 정의:순수 가상 함수가 포함되어 있어, 객체를 생성했을 때 호출할 수 있는 실제 메서드 구현이 없습니다. 이러한 불완전함 때문에 인스턴스를 생성할 수 없습니다. <br>
  2. 상속의 기반:추상 클래스는 주로 상속을 통해 자식 클래스에 공통 기능을 제공하거나 인터페이스 역할을 합니다. <br>
  3. 의미적인 이유:추상 클래스는 개념적으로 다른 클래스에서 구현되어야 하는 기반 또는 인터페이스 역할을 합니다. 따라서 인스턴스화가 불가능하도록 설계되어, 오직 상속과 다형성을 위한 용도로 사용됩니다. <br>
</details>
  


Q. 클래스와 인스턴스의 차이?  
A. 클래스는 객체를 생성하기 위한 설계도, 인스턴스는 그 설계도로부터 생성된 실제 객체입니다.  


Q. 가상함수 테이블?  
A. 가상함수 테이블은 함수 포인터들을 모아둔 배열입니다.  
객체의 가상함수 포인터를 통해서 클래스의 가상함수 테이블에 접근합니다.  
가상함수 테이블 안의 함수 포인터를 호출하는 방식으로 동작합니다.  


Q. 가상함수 테이블은 어느 시점에 생기는가?  
A. 컴파일 타임에 만들어집니다.  

Q. 가상 함수? 
부모 클래스의 포인터나 레퍼런스가 자식 클래스 객체를 가리킬 때, 자식 클래스에서의 가상 함수 재정의에 의해 호출되는 함수가 달라지게 합니다. 다형성의 구현을 위해 도입되었습니다.   


Q. 컴파일러는 가상함수를 어떻게 처리하는가?  
- 컴파일러는 **가상 함수 테이블(VTable)**과 **VTable 포인터(vptr)**를 클래스에 생성.  
- 객체 생성 시 vptr이 실제 타입의 VTable을 가리키고,  
- 가상 함수 호출은 vptr을 통해 **간접 호출**되어 다형성 구현.  


Q. 클래스가 가상 테이블을 갖고 있는건가요? 아니면 모든 인스턴스가 다 갖고 있나요? 
A. 클래스당 1개입니다.  


Q. 오브젝트가 있고, 오브젝트에서 가상함수를 선언했다. 그걸 상속받는 몬스터가 있다. 몬스터가 100마리 있다고 치자. 몬스터가 어택함수를 썼다. 그러면 몬스터가 100마리니까 가상테이블도 100개일까?  
A. 가상테이블은 1개입니다.  


Q. 가상 테이블은 어느 메모리 영역에 존재하는가?  
- 가상함수 테이블은 클래스에 가상함수를 선언하면 **코드 영역**에 생성됩니다.   
- 가상함수 테이블이 생성되면 객체의 메모리 영역에 가상 테이블을 가리킬 포인터가 생성됩니다  


<br>


객체 생성 및 소멸 과정 중에는 절대로 가상 함수를 호출하지 말자  