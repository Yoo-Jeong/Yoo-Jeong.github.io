---
title: Q.바인딩
#author: Yoojeong
date: 2024-11-07 14:30:00 +0800
categories: [Study, C/C++]
tags: [c, c++, tech interview]
render_with_liquid: false
---


Q. 바인딩?  
A. 프로그램 내에서 특정 이름(변수, 함수, 객체 등)과 해당 이름이 참조하는 실제 메모리 위치 또는 실행코드를 연결하는 과정입니다.  


Q. 정적바인딩과 동적바인딩?  
A. 정적 바인딩은 컴파일 타임에 호출 대상이 결정되어 성능과 최적화에 유리하고, 동적 바인딩은 런타임 다형성을 제공해 확장성과 유지보수성이 좋지만, 가상 함수 호출 비용과 최적화 제약이 있습니다.  

+ `final` → 동적 바인딩이지만 정적 바인딩처럼 최적화 가능  

동적바인딩은 virtual화 하여 오버라이딩을 하면 참조된 인스턴스의 실제 데이터 클래스 형에 따라 재정의 된 함수가 호출됩니다.   


| 구분      | 정적 바인딩      | 동적 바인딩     |
| --------- | ---------------- | --------------- |
| 결정 시점 | 컴파일 타임      | 런타임          |
| 구현 방식 | 직접 호출        | vtable 기반     |
| 다형성    | X                | O               |
| 성능      | 빠름             | 상대적으로 느림 |
| 인라이닝  | 가능             | 제한적          |
| 유연성    | 낮음             | 높음            |
| 유지보수  | 구조 변경에 취약 | 확장에 강함     |



Q. 동적바인딩의 장단점?  
A. 동적바인딩은 다형성을 통해 확장성과 유지보수성을 높이지만, 가상 함수 호출 비용과 최적화 제약으로 인해 성능이 중요한 구간에서는 신중히 사용해야 합니다.   

장점
- 다형성 지원:부모 타입 포인터/참조로 자식 객체를 다룰 수 있어, 코드의 유연성과 확장성이 높아집니다.  
- 유지보수성 향상: 새로운 파생 클래스를 추가해도 기존 로직을 수정하지 않고 기능 확장이 가능합니다 (OCP)  

단점
- 성능 오버헤드: 가상 함수 호출 시 vtable 탐색이 필요하여 정적 바인딩보다 호출 비용이 증가합니다.  
- 인라이닝 제한: 컴파일 타임에 호출 대상이 확정되지 않아 함수 인라이닝이 어렵습니다->최적화에 불리  
- 디버깅 난이도: 실체 호출되는 함수가 런타임에 결정되므로 호출 흐름을 추적하기가 상대적으로 어렵습니다.  


UI, 상태 전환, 이벤트 처리, FSM 상태 클래스 등의 경우에는 동적바인딩을 사용해도 괜찮지만, 렌더링 루프, 물리 계산 등 대량 반복 호출의 경우 피하는 것이 좋습니다.  


<br>

---

<br>

생성된 객체 기준이지, 자료형이 기준이 아니다. 누구의 주소냐가 중요하다.
```cpp
CObj* pObj = new CObj; // 부모의 vptr
CObj* pObj = new CPlayer; // 자식의 vptr
```
자료형은 포인터 CObj* 이지만 주소는 CPlayer이기 때문에