---
title: 정보처리기사
#author: Yoojeong
date: 2025-06-20 19:00:00 +0800
categories: [Study, etc]
tags: [이론]
math: true
render_with_liquid: false
---

완전수 : 0, 6, 28, 496, 8128  
A 65, a 97  

---

# 요구사항 확인  

## GoF 디자인 패턴
1. 생성 패턴 - 생빌 프로 팩앱싱
- **Builder** : 복잡한 인스턴스를 조립하여 만드는 구조로, 생성과 표기를 분리해 복잡한 객체를 생성한다.  
- **Prototype** : 처음부터 일반적인 원형을 만들어 놓고, 그것을 복사한 후 필요한 부분만 수정하여 사용한다.  
- **Factory Method** : 상위 클래스에서 인터페이스를 정의하고 하위 클래스에서 인터페이스를 생성한다.  
- **Abstract Factory** : 구체적인 클래스에 의존하지 않고 서로 연관되거나 의존적인 객체들의 조합을 만드는 인터페이스를 제공한다.
- **Singleton** : 한 클래스에 한 인스턴스만 존재하도록 제한한다.  

<br>

2. 구조 패턴 - 구 브데 퍼플 프록 컴어
- **Bridge**  
- **Decorator**  
- **Facade**  
- **Flyweight**  
- **Proxy** : 대리자, 정보 은닉, 메모리 용량 절약  
- **Composite**  
- **Adapter**  

<br>

3. 행위 패턴 - 행 미인이 템옵 스테 비커 스트 메체  
- **Mediator** : 중재자  
- **Interpreter**  
- **Iterator**  
- **Template Method**  
- **Observer**  
- **State**  
- **Visitor**  
- **Command**  
- **Strategy**  
- **Memento**  
- **Chain of Responsibility**  

<br>

---

# 데이터 입출력

카행 레코드 튜플 *  
디열 필드 어트리뷰트 +  


## 데이터베이스 정규화 단계  

원부이 결다조  

- **1정규형(1NF)** : 원자값으로 구성  
- **2정규형(2NF)** : 부분 함수 종속 제거 -> 완전 함수 종속 관계  
- **3정규형(3NF)** : 이행 함수 종속 제거
- **보이스-코드 정규형(BCNF)** : 결정자 후보 키가 아닌 함수 종속 제거  
- **4정규형(4NF)** : 다치(다중 값) 종속 제거  
- **5정규형(5NF)** : 조인 종속 제거  

<br>

## 키의 종류
1. **슈퍼 키(Super Key)**
- 릴레이션을 구성하는 모든 튜플에 대해 유일성은 만족하지만, 최소성은 만족하지 못하는 키  
2. **후보 키(Candidate Key)**
- 테이블에서 각 튜플들을 구별하는데 기준이 되는 컬럼(기본키 + 대체 키)
3. **대체 키(Alternate Key)**
- 후보 키 중에서 기본 키로 선택되지 않은 키
4. **기본 키(Primary Key)**
- 테이블의 각 튜플들을 고유하게 식별하는 컬럼
5. **외래 키(Foreign Key)**
- 테이블 간의 참조 데이터 무결성을 위한 제약 조건, 한 릴레이션의 컬럼이 다른 릴레이션의 기본 키로 이용되는 키 (다른 참조 테이블의 기본 키?)

<br>

---

## 무결성
데이터베이스에 저장된 데이터 값과 그것이 표현하는 현실 세계의 실제값이 일치하는 정확성을 의미한다.  

* 개체 무결성  
-- 기본 테이블의 기본키를 구성하는 어떤 속성도 Null값이나 중복값을 가질 수 없다는 규정  

* 참조 무결성  
-- 외래키 값은 Null이거나 참조 릴레이션의 기본키 값과 동일해야 함. 즉 릴레이션은 참조 할 수 없는 외래기 값을 가질 수 없다는 규정  

<br>

---

# 서버 프로그램 구현

## 응집도(Cohesion)
우논시절 통순기 - 응집도는 강하게(높게)

↑  
- **기능적 응집도** : 모듈 내부의 모든 기능이 단일힌 목적을 위해 수행  
- **순차적 응집도** : 출력값이 입력값으로 사용  
- **통신적 응집도** : 동일한 입력/출력을 사용해 다른 기능을 수행  
- **절차적 응집도** : 순차적으로 수행  
- **시간적 응집도** : 특정 시간에 처리되어야 하는 활동을 한 모듈에서 처리  
- **논리적 응집도** : 유사한 성격의 처리요소들을 한 모듈에서 처리  
- **우연적 응집도** : 모듈 내부의 각 구성 요소들이 연관 없음  
  
↓   

<br>

---

## 결합도(Coupling)
내공외제스자 - 결합도는 약하게

- **자료 결합도** : 모듈간의 자료(값)를 통해서만 모듈 상호 작용 발생  
- **스탬프 결합도** : 모듈간의 배열이나 오브젝트, 스트럭처 등이 전달되는 경우  
- **제어 결합도** : 값만 전달되는게 아니라, 제어 요소가 전달되는 경우  
- **외부 결합도** : 모듈에서 외부로 선언한 변수를 다른 모듈에서 참조  
- **공통 결합도** : 전역변수를 참조  
- **내용 결합도** : 다른 모듈 내부에 있는 변수나 기능을 또 다른 모듈에서 사용  

<br>

---

# 애플리케이션 테스트 관리

## 화이트박스 테스트  
구결조 조변다 기제데루 : 각 응용 프로그램의 내부 구조와 동작을 검사하는 소프트웨어 테스트이다.  

1. **구문 커버리지 = 문장 커버리지(Statement Coverage)**  
- 프로그램 내의 모든 명령문을 적어도 한 번 수행
2. **결정 커버리지 = 선택 커버리지(Decision Coverage) = 분기 커버리지(Branch Coverage)**  
- 각 분기의 결정 포인트 내의 전체 조건식이 적어도 한 번은 참과 거짓의 결과를 수행  
3. **조건 커버리지(Condition Coverage)**
- 각 분기의 결정 포인트 내의 각 개별 조건식이 적어도 한 번은 참과 거짓의 결과가 되도록 수행
4. **조건/결정 커버리지(Condition/Decision Coverage)**
- 전체 조건+개별 조건식 둘 다 참 한 번, 거짓 한 번 결과가 되도록 수행  
5. **변경 조건/결정 커버리지(Modified Condition/Decision Coverage)**
- 개별 조건식이 다른 개별 조건식에 영향을 받지 않고 전체 조건식에 독립적으로 영향을 주도록 함으로써 조건/결정 커버리지를 향상시킨 커버리지이다.  
6. **다중 조건 커버리지(Multiple Condition Coverage)**
- 결정 조건 내 모든 개별 조건식의 모든 가능한 조합을 100% 보장하는 커버리지이다.  
7. **기본 경로 커버리지 = 경로 커버리지(Bass Path Coverage)**
- 수행 가능한 모든 경로를 테스트하는 기법
8. **제어 흐름 커버리지(Control Flow Testing)**
- 프로그램 제어 구조를 그래프 형태로 나타내어 내부 로직을 테스트
9. **데이터 흐름 테스트(Data Flow Testing)**
- 제어 흐름 그래프에 데이터 사용현황을 추가한 그래프를 통해 테스트
10. **루프 테스트(Loop Testing)**
- 프로그램의 반복 구조에 초점을 맞춰 실시하는 테스트 기법

<br>

---

## 블랙박스 테스트  
동경결 원비오 : 프로그램 외부 사용자의 요구사항 명세를 보면서 수행하는 테스트(기능 테스트)이다.  

1. **동등분할 테스트 = 동치 분할 테스트, 균등분할 테스트, 동치 클래스 분해 테스트(Equivalence Partitioning Testing)**
- 입력 데이터의 영역을 유사한 도메인별로 유효값/무효값을 그룹핑하여 대푯값 테스트 케이스를 도출
2. **경계값 분석 테스트 = 한곗값 테스트(Boundary Value Analysis Testing)**
- 등가 분할 후 경계값 부분에서 오류 발생 확률이 높기 때문에 경계값을 포함하여 테스트 케이스를 설계하여 테스트
3. **결정 테이블 테스트(Decision Table Testing)**
- 요구사항의 논리와 발생 조건을 테이블 형태로 나열하여, 조건과 행위를 모두 조합하여 테스트
4. **원인-결과 그래프 테스트(Cause-Effect Graph Testing)**
- 그래프를 활용하여 입력 데이터 간의 관계 및 출력에 미치는 영향을 분석하여 효용성이 높은 테스트 케이스를 선정하여 테스트
5. **비교 테스트(Comparsion Testing)**
- 여러 버전의 프로그램에 같은 입력값을 넣어서 동일한 결과 데이터가 나오는지 비교
6. **오류 예측 테스트(Error Guessing Testing)**
- 개발자가 범할 수 있는 실수를 추정하고 이에 따른 결함이 검출되도록 테스트 케이스를 설계