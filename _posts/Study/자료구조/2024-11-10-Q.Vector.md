---
title: Q.Vector
#author: Yoojeong
date: 2024-11-10 11:00:00 +0800
categories: [Study, 자료구조]
tags: [자료구조, c, c++, STL, tech interview]
render_with_liquid: false
---


Q. vector?  

Q. array와 vector의 차이    

Q. vector의 시간, 공간 복잡도  

Q. vector의 capacity란?   

Q. capacity를 지우고 싶다면?  

Q. vector 재할당 시 메모리 크기를 얼마로 할당하는가?  

Q. vector는 어떻게 크기가 바뀔 수 있나요?

Q. vector는 어느 메모리에 위치하나요?  

Q. resize와 reserve함수를 각각 언제 사용하는가?   

Q. vector에 reserve(100)을 하고, push_back()을 하면 어떤 동작이 이루어지는가? 

Q. 일반적으로 원소를 그냥 erase하면 문제가 생긴다. 왜 생기는가?  

Q. 순회할 때 vecotr가 list보다 빠른 이유?  

Q. vector를 복사하면 어떤 과정이 이루어지는가?    

Q. vector 사용경험?  

<br>

---

<br>

## 주요 함수  


1. 추가/삭제 → `push_back()`, `pop_back`, `insert( , )`, `erase( , )`  

2. 정보 확인 → `size`, `empty`, `front`, `back`

3. 정렬 → `sort( , )`, `( , )`, `min_element( , )`, `max_element( , )`  

5. 탐색 → `find( , )`, `count( , , )`

<br>

**선언 & 초기화**
```cpp
vector<int> v;               // 빈 벡터
vector<int> v(10);           // 크기 10, 기본값 0
vector<int> v(10, 5);        // 크기 10, 모든 원소 5
vector<int> v2 = {1, 2, 3};  // 초기화 리스트
```

<br>

**원소 접근**
```cpp
v[i];           // 인덱스 접근 (0-based)
v.at(i);        // 범위 체크 포함 (예외 발생 가능)
v.front();      // 첫 번째 원소
v.back();       // 마지막 원소
```

<br>

**크기 관련**
```cpp
v.size();       // 현재 원소 개수
v.empty();      // 비어있으면 true
v.clear();      // 모든 원소 삭제
```

<br>

**삽입 & 삭제**
```cpp
v.push_back(x);              // 맨 뒤에 삽입
v.pop_back();                // 맨 뒤 원소 삭제
v.insert(v.begin() + i, x);  // i번째 위치에 삽입
v.erase(v.begin() + i);      // i번째 원소 삭제
v.erase(v.begin() + a, v.begin() + b); // [a, b) 구간 삭제
```

<br>

**반복자**
```cpp
for(auto it = v.begin(); it != v.end(); it++) cout << *it;
for(int x : v) cout << x;   // range-based for
```

<br>


**정렬 & 알고리즘** (algorithm 헤더 필요)
```cpp
sort(v.begin(), v.end());                  // 오름차순 정렬
sort(v.begin(), v.end(), greater<int>());  // 내림차순 정렬
reverse(v.begin(), v.end());               // 순서 뒤집기
```

<br>

**기타 유용한 함수**
```cpp
find(v.begin(), v.end(), x);      // 값 x 찾기 (없으면 v.end() 반환)
count(v.begin(), v.end(), x);     // 값 x 개수 세기
min_element(v.begin(), v.end());  // 최소값 위치 반복자
max_element(v.begin(), v.end());  // 최대값 위치 반복자
```